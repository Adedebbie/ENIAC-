# -*- coding: utf-8 -*-
"""data quality.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D4ke-XWEqXZerYgVtySHrVbQnm_gQd4h
"""

import pandas as pd
pd.set_option('display.float_format', lambda x: '%.2f' % x)
pd.set_option('display.max_rows', 1000)

# orderlines.csv
url = 'https://drive.google.com/file/d/14Y7g5ITyf6LMyPoKc9wr010V9StaCUux/view?usp=sharing' 
path = 'https://drive.google.com/uc?export=download&id='+url.split('/')[-2]
orderlines = pd.read_csv(path)

# orders.csv
url = 'https://drive.google.com/file/d/1BLEHcP-9fm9Rv7A01H3co2XBMnSr66YC/view?usp=sharing' 
path = 'https://drive.google.com/uc?export=download&id='+url.split('/')[-2]
orders = pd.read_csv(path)

print(path)

# brands.csv
url = 'https://drive.google.com/file/d/1BrNrIY0F1LbyXtyaQygUBXVxQGB3JBqx/view?usp=sharing' 
path = 'https://drive.google.com/uc?export=download&id='+url.split('/')[-2]
brands = pd.read_csv(path)

# products.csv
url = 'https://drive.google.com/file/d/1UfsHI80cpQqGfsH2g4T4Tsw8cWayOfzC/view?usp=sharing' 
path = 'https://drive.google.com/uc?export=download&id='+url.split('/')[-2]
products = pd.read_csv(path)

df_list = [orderlines, orders, brands, products]
files = ['orderlines','orders','brands','products']

#orders_cl.csv
path = 'https://drive.google.com/uc?export=download&id=1cGjJ9o3vtwjK0Sohyr3YVTccXfnTPijT' 
orders_cl = pd.read_csv(path)

#orderlines_cl.csv
path = 'https://drive.google.com/uc?export=download&id=1lrSr_vVbXN7QSVSScf68DpWwvCMclK5m'
orderlines_cl = pd.read_csv(path)

#brands_cl.csv
path = 'https://drive.google.com/uc?export=download&id=1XGyabaa4mAkjixMk3XPgx_14OoSse3rs'
brands_cl = pd.read_csv(path)

#products_cl.csv
path = 'https://drive.google.com/uc?export=download&id=1rHC8M-HG13FtVncImXBydgDtIHyCPH0g'
products_cl = pd.read_csv(path)

"""*# CLEANING DATA* """

#filter out completed orders
orders_cl.head()

orders_cl.columns

products_cl.columns

orderlines_cl.columns

#unique states of orders
print(orders_cl['state'].unique())

# creating new df for orders containing just 'completed' as state of order

new_orders_cl = orders_cl[(orders_cl['state'] == 'Completed')] 
new_orders_cl

#creating new column to check if id_order is present in orders data set
orderlines_cl.assign(check_orders_cl = orderlines_cl['id_order'].isin(orders_cl['order_id']))

#selecting rows where the values in check_orders is false to know those that are not present in orders df 
(
orderlines_cl
    .assign(check_orders_cl = orderlines_cl['id_order'].isin(orders_cl['order_id']))
    .query("check_orders_cl==False")
)
#orderlines_cl.head()

#check for rows that are in orderlines but not in products
orderlines_cl.loc[~orderlines_cl['sku'].isin(products_cl['sku'])].copy()

# Creating new df containing rows that are present in both products and orderlines 
new_orderlines_cl = orderlines_cl.loc[~((orderlines_cl.sku.isin(products_cl['sku'])))].copy()
new_orderlines_cl.head()

#drop values that are in new_orderlines_cl but not in orderlines_cl
cond = orderlines_cl['sku'].isin(new_orderlines_cl['sku'])
orderlines_cl.drop(orderlines_cl[cond].index, inplace = True)
orderlines_cl

#orderlines_ = orderlines.loc[orderlines["_merge"] == "left_only"].drop("_merge", axis=1)
print('EVU0007' in orderlines_cl['sku'].unique())

orderlines_cl['sku'].count()

print("Duplicate rows:", products_cl.duplicated().sum())

products_cl['sku'].count()

#drop values that are in orderline but not in products
products_cl.loc[~products_cl['sku'].isin(orderlines_cl['sku'])].copy()
#products

#rename orderline_cl id_order to order_id
orderlines_cl.rename(columns = {'id_order':'order_id'}, inplace = True)
orderlines_cl

# create a new column "unit_price_total" by multiplying product_quantity with unit_price
orderlines_cl['unit_price_total'] = orderlines_cl['product_quantity'] * orderlines_cl['unit_price']
orderlines_cl.head()

orderlines_cl_grped = orderlines_cl.groupby(orderlines_cl["order_id"]).unit_price_total.agg(["sum",
                                              ])
orderlines_cl_grped

orderlines_cl_grped.rename(columns = {'sum':'unit_price_total'}, inplace = True)
orderlines_cl_grped

merged_orders = new_orders_cl.merge(orderlines_cl_grped,on=['order_id'] ,how='left')
merged_orders

merged_orders['price_diff'] = merged_orders['total_paid'] - merged_orders['unit_price_total']
merged_orders

#merged products and orderline df
merged_products = products_cl[['price','sku']].merge(orderlines_cl[['order_id','unit_price','sku']], on = 'sku',how = 'right')
merged_products.head()

merged_products['price_diff'] = merged_products['price'] - merged_products['unit_price']
merged_products.head()

pd.set_option('display.max_rows', 1000)
pd.set_option("display.max_colwidth", 200)

products_cl[].max()

products_cl['price'].min()

"""How products should be classified into different categories to simplify reports and analysis\n
What is the distribution of product prices across different categories\n.
How many products are being discounted.
How big are the offered discounts as a percentage of the product prices.
How seasonality and special dates (Christmas, Black Friday) affect sales.
How could data collection be improved.
"""

merged_products.shape

min(merged_products['price_diff'])

max(merged_products['price_diff'])

"""**CATEGORISING DATA**"""

pd.set_option('display.max_rows', 1000)
pd.set_option("display.max_colwidth", 200)

#products_cl[products_cl['name'].str.contains(r"^iphone", regex=True, case=False)]

import regex as re

iphone_regex = re.compile(r"^iphone", flags=re.IGNORECASE)

products_cl['category'] = products_cl.apply(lambda x: 'smartphone' if iphone_regex.search(x['name']) else 'nan', axis=1)
products_cl.head()

#products_cl['category'].value_counts()

